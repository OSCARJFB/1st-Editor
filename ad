[1mdiff --git a/src/editorMode.c b/src/editorMode.c[m
[1mindex b273402..878ce18 100644[m
[1m--- a/src/editorMode.c[m
[1m+++ b/src/editorMode.c[m
[36m@@ -680,9 +680,9 @@[m [mstatic inline void setRightMargin(int y, TEXT *node)[m
 static inline void setBottomMargin(TEXT *node)[m
 {[m
 	_margins.bottom = node->y;[m
[31m-	if (node->next == NULL && node->ch == '\n')[m
[32m+[m	[32mif(node->next != NULL)[m
 	{[m
[31m-		_margins.bottom += _margins.bottom < _view ? 1 : 0;[m
[32m+[m		[32m++_margins.bottom;[m[41m [m
 	}[m
 }[m
 [m
[36m@@ -831,24 +831,34 @@[m [mstatic dataCopied copy(dataCopied cpyData, TEXT *headNode, coordinates xy)[m
 [m
 /**[m
  * Count how many newlines that exists within the bounds of the terminal view.[m
[31m- * This is usefull to help determine when we've added more items to the TEXT list than may be viewed in the terminal. [m
[32m+[m[32m * This is used to help determine when we've added more items to the TEXT list than may be viewed in the terminal.[m[41m [m
  */[m
 static int countNewLinesInView(TEXT *headNode)[m
 {[m
 	int newlines = 0;[m
 [m
[31m-	while (headNode != NULL && newlines != _view + 1)[m
[32m+[m	[32mfor (TEXT *node = headNode; node != NULL && newlines != _view + 1; node = node->next)[m
 	{[m
 		if (headNode->ch == '\n')[m
 		{[m
 			++newlines;[m
 		}[m
[31m-[m
[31m-		headNode = headNode->next;[m
 	}[m
[32m+[m
 	return newlines;[m
 }[m
 [m
[32m+[m[32mbool isEndNode(TEXT *editedNode)[m
[32m+[m[32m{[m
[32m+[m	[32mfor(TEXT *node = editedNode; node->next != NULL; node = node->next)[m
[32m+[m	[32m{[m
[32m+[m		[32mif(node->y == _view && node->next != NULL)[m
[32m+[m		[32m{[m
[32m+[m			[32mreturn false;[m[41m [m
[32m+[m		[32m}[m
[32m+[m	[32m}[m
[32m+[m	[32mreturn true;[m[41m [m
[32m+[m[32m}[m
 [m
 /**[m
  * Update view port of the text.[m
[36m@@ -869,7 +879,7 @@[m [mstatic void updateViewPort(coordinates xy, int ch, TEXT *headNode)[m
 	{[m
 		--_viewStart;[m
 	}[m
[31m-	else if (xy.y < _view && newLines > _view && ch == KEY_DOWN) // ERROR HERE. This check won't prevent us from navigating out of bounds.[m
[32m+[m	[32melse if (newLines > _view && !isEndNode(editedNode) && ch == KEY_DOWN) // ERROR HERE. This check won't prevent us from navigating out of bounds.[m
 	{[m
 		++_viewStart;[m
 	}[m
[36m@@ -992,7 +1002,6 @@[m [mvoid runApp(TEXT *headNode, char *fileName)[m
 				break;[m
 		}[m
 		[m
[31m-		// This is the correct order of execution. [m
 		updateViewPort(xy, ch, headNode);[m
 		updateMargins(xy.y, ch, headNode);[m
 		updateCoordinatesInView(&headNode);[m
